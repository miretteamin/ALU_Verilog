//Anding 3 dataflow
module and_3 (output out, input a, input b,  input c);
    wire andout;
    and(andout, a, b);
    and(out, andout, c);
endmodule

//Oring 4 dataflow
module or_4 (output out, input a, input b,  input c, input d);
    wire orout1, orout2;
    or(orout1, a, b);
    or(orout2, c, d);
    or(out, orout1, orout2);
endmodule

//Full Adder
module full_adder(output sum, output carry, input x, input y, input cin);
    wire s1, c1, c2;
    xor(s1, x, y);
    and(c1, x, y);
    xor(sum, s1, cin);
    and(c2, s1, cin);
    or(carry, c1, c2);
endmodule

//4x1 Multiplexer
module mux4x1 (output out, input a,  input b,  input c, input d, input s1, input s0);
    wire ns0, ns1;
    not(ns0,s0);
    not(ns1,s1);

    wire o1, o2, o3, o4;
    and_3 and_30(o1, ns0, ns1, a);
    and_3 and_31(o2, s0, ns1, b);
    and_3 and_32(o3, ns0, s1, c);
    and_3 and_33(o4, s0, s1, d);

    or_4 or_40(out, o1, o2, o3, o4);
endmodule

//2x1 Multiplexer
module mux2x1 (output out, input a,  input b, input s);
    wire ns;
    not(ns,s);

    wire o1, o2;
    and(o1, ns, a);
    and(o2, s, b);

    or(out, o1, o2);
endmodule

//Arithmetic Circuit: 4 operations
module ac (output [3:0] out, output carry, input[3:0] a, input[3:0] b, input[1:0] sel);

    /* 
                *----Description----*
    * Adding 2 numbers: s1 = 0 , s0 = 0, cin = 0
    * Subtracting 2 numbers: s1 = 0, s0 = 1, cin = 1 
    * Adding 1 to a number: s1 = 1, s0 = 0, cin = 1
    * Subtracting 1 from a number: s1 = 1, s0 = 1, cin = 0

    * So, cin is XOR of s0 and s1  then cin will be 1 in case of adding 1 to number and subtraction 2 numbers
    */

    wire o1, o2, o3, o4, c1, c2, c3;
    wire nb0, nb1, nb2, nb3;

    not(nb0,b[0]);
    not(nb1,b[1]);
    not(nb2,b[2]);
    not(nb3,b[3]);

    wire cin;
    xor(cin, sel[0], sel[1]);

    mux4x1 mu0(o1, b[0], nb0, 1'b0, 1'b1, sel[1], sel[0]);
    full_adder full_adder0(out[0], c1, a[0], o1, cin);

    mux4x1 mu1(o2, b[1], nb1, 1'b0, 1'b1, sel[1], sel[0]);
    full_adder full_adder1(out[1], c2, a[1], o2, c1);

    mux4x1 mu2(o3, b[2], nb2, 1'b0, 1'b1, sel[1], sel[0]);
    full_adder full_adder2(out[2], c3, a[2], o3, c2);

    mux4x1 mu3(o4, b[3], nb3, 1'b0, 1'b1, sel[1], sel[0]);
    full_adder full_adder3(out[3], carry, a[3], o4, c3);

endmodule

//Logic Circuit 
module lc (output [3:0] out, input[3:0] a, input[3:0] b, input[1:0] sel);

    /* 
                *----Description----*
    * ANDING 2 numbers: s1 = 0, s0 = 0 or s1 = 0, s0 = 1 
    * ORING 2 numbers: s1 = 1, s0 = 0 
    * XORING 2 numbers: s1 = 1, s0 = 1 

    */

    wire and0, and1, and2, and3;
    and(and0, a[0], b[0]);
    and(and1, a[1], b[1]);
    and(and2, a[2], b[2]);
    and(and3, a[3], b[3]);

    wire or0, or1, or2, or3;
    or(or0, a[0], b[0]);
    or(or1, a[1], b[1]);
    or(or2, a[2], b[2]);
    or(or3, a[3], b[3]);

    wire xor0, xor1, xor2, xor3;
    xor(xor0, a[0], b[0]);
    xor(xor1, a[1], b[1]);
    xor(xor2, a[2], b[2]);
    xor(xor3, a[3], b[3]);


    mux4x1 mu0(out[0], and0, and0, or0, xor0, sel[1], sel[0]);
    mux4x1 mu1(out[1], and1, and1, or1, xor1, sel[1], sel[0]);
    mux4x1 mu2(out[2], and2, and2, or2, xor2, sel[1], sel[0]);
    mux4x1 mu3(out[3], and3, and3, or3, xor3, sel[1], sel[0]);

endmodule
////////////////////////////////////////

module ShiftRegister_SIPO(C, SI, PO);
input C,SI;
output [3:0] PO;
reg [3:0] tmp;

always @(posedge C)
begin
tmp = {tmp[2:0], SI};
end
assign PO = tmp;
endmodule

module ars (output [3:0]out, input[3:0]in);

    buf(out[0],in[1]);
    buf(out[1],in[2]);
    buf(out[2],in[3]);
    buf(out[3],in[3]);
    
endmodule


//arithmetic logic unit
module alu (output [4:0] out , input [3:0] a , input [3:0] b , input [3:0]sel);
    // wire o0,o1,o2,o3 //ac output
    wire [3:0]acout;
    // wire l0,l1,l2,l3 // lc output
    wire [3:0]lcout;
    // wire c1 , c2 , c3 , c4
    wire outcarry;
    // wire cin 
    wire [3:0]shiftrig;
    wire [3:0]arsout;
    // wire f0,f1,f2,f3
    
    
    
    /* 
    * Logic Circuit output s3=0 / s2 =0   
    *Arithmetic Circuit    s3 =0 /  s2=  1 
    *shift right            s3 = 1 / s2 =  0 Or s3 = 1/  s2 =  1 

    */
    
    // ac(o0,c1,a[0],b[0],sel[1],sel[0]);
    lc lc1(lcout,a,b,{sel[1],sel[0]});
    ars ars1(arsout,a);
    ac ac1(acout,outcarry,a,b,{sel[1],sel[0]});
    buf(out[4],outcarry);
    mux4x1 mu0(out[0],lcout[0],acout[0],arsout[0],arsout[0],sel[3],sel[2]);
    mux4x1 mu1(out[1],lcout[1],acout[1],arsout[1],arsout[1],sel[3],sel[2]);
    mux4x1 mu2(out[2],lcout[2],acout[2],arsout[2],arsout[2],sel[3],sel[2]);
    mux4x1 mu3(out[3],lcout[3],acout[3],arsout[3],arsout[3],sel[3],sel[2]);
    // buf(out[4],outcarry);


    // mux4x1(f0 , o0 , l0 , shiftrig , ShiftRegister_SIPO , sel[2],sel[3]);
    
    // ac(o1,c2,a[1],b[1],sel[1],sel[0]);
    // lc(l1,a[1],b[1],sel[1],sel[0]);
    // mux4x1(f1 , o1 , l1 , shiftrig , ShiftRegister_SIPO , sel[2],sel[3]);
    
    // ac(o2,c3,a[2],b[2],sel[1],sel[0]);
    // lc(l2,a[2],b[2],sel[1],sel[0]);
    // mux4x1(f2 , o2 , l2 , shiftrig , ShiftRegister_SIPO , sel[2],sel[3]);
    
    // ac(o3,c4,a[3],b[3],sel[1],sel[0]);
    // lc(l2,a[3],b[3],sel[1],sel[0]);
    // mux4x1(f3 , o3 , l3 , shiftrig , ShiftRegister_SIPO , sel[2],sel[3]);
    
endmodule

module Test_ALU();

    reg [3:0] A;
    reg [3:0] B;
    reg [4:0] s;

    wire [4:0] out;

    alu alu(out, A, B, s);

    initial 
    begin
        $monitor($time, " carry=%b,    out = %b%b%b%b     ,    s = %b%b%b%b", out[4],out[3], out[2], out[1], out[0], s[3],s[2],s[1],s[0]);

        A[3] <= 1; A[2] <=0 ; A[1] <= 0; A[0] <= 0;
        B[3] <= 1; B[2] <= 0; B[1] <= 1; B[0] <= 1;

        #10 s[3] <= 0; s[2] <= 0; s[1] <= 0; s[0] <= 0;
        #10 s[3] <= 0; s[2] <= 0; s[1] <= 0; s[0] <= 1;
        #10 s[3] <= 0; s[2] <= 0; s[1] <= 1; s[0] <= 0;
        #10 s[3] <= 0; s[2] <= 0; s[1] <= 1; s[0] <= 1;
        #10 s[3] <= 0; s[2] <= 1; s[1] <= 0; s[0] <= 0;
        #10 s[3] <= 0; s[2] <= 1; s[1] <= 0; s[0] <= 1;
        #10 s[3] <= 0; s[2] <= 1; s[1] <= 1; s[0] <= 0;
        #10 s[3] <= 0; s[2] <= 1; s[1] <= 1; s[0] <= 1;
        #10 s[3] <= 1; s[2] <= 0; s[1] <= 0; s[0] <= 0;
        #10 s[3] <= 1; s[2] <= 0; s[1] <= 0; s[0] <= 1;
        #10 s[3] <= 1; s[2] <= 0; s[1] <= 1; s[0] <= 0;
        #10 s[3] <= 1; s[2] <= 0; s[1] <= 1; s[0] <= 1;
        #10 s[3] <= 1; s[2] <= 1; s[1] <= 0; s[0] <= 0;
        #10 s[3] <= 1; s[2] <= 1; s[1] <= 0; s[0] <= 1;
        #10 s[3] <= 1; s[2] <= 1; s[1] <= 1; s[0] <= 0;
        #10 s[3] <= 1; s[2] <= 1; s[1] <= 1; s[0] <= 1;

        $finish;
    end
endmodule
////////////////////
